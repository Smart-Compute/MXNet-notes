## InputSplit
```
 class InputSplit {
  public: 
   struct Blob {  // 定义内存块
     void *dptr;  // 起始位置
     size_t size; // 内存块大小
   };
   virtual ~InputSplit(void) DMLC_THROW_EXCEPTION {}
   virtual void HintChunkSize(size_t chunk_size) {}
   virtual size_t GetTotalSize(void) = 0;
   virtual void BeforeFirst(void) = 0;
   virtual bool NextRecord(Blob *out_rec) = 0;  // text: 返回下一行; recordio: 返回下一个record
   /*
    * get a chunk of memory that can contain multiple records
    * This function ensures there won't be partial record in the chunk
    */
   virtual bool NextChunk(Blob *out_chunk) = 0;
   virtual bool NextBatch(Blob *out_chunk, size_t n_records) {
     return NextChunk(out_chunk);
   }
   virtual void ResetPartition(unsigned part_index, unsigned num_parts) = 0; // 重置为新的分片
   
   static InputSplit* Create(const char *uri, unsigned part_index, unsigned num_parts, const char *type);
   static InputSplit* Create(const char *uri, const char *index_uri, unsigned part_index, unsigned num_parts,
                             const char *type, const bool shuffle = false, const int seed = 0,
                             const size_t batch_size = 256, const bool recurse_directories = false);
 };
```
## InputSplitBase
```
 class InputSplitBase : public InputSplit {
  public:                    
   /*!                       
    * \brief helper struct to hold chunk data
    *  with internal pointer to move along the record
    */                       
   struct Chunk {            
     char *begin;            
     char *end;              
     std::vector<uint32_t> data;
     explicit Chunk(size_t buffer_size)
         : begin(NULL), end(NULL),
           data(buffer_size + 1) {}
     // load chunk from split
     bool Load(InputSplitBase *split, size_t buffer_size);
     // append to chunk
     bool Append(InputSplitBase *split, size_t buffer_size);
   };
   // 16 MB
   static const size_t kBufferSize = 2UL << 20UL;
   // destructor
   virtual ~InputSplitBase(void);
   // implement BeforeFirst
   virtual void BeforeFirst(void);
   virtual void HintChunkSize(size_t chunk_size) {
     buffer_size_ = std::max(chunk_size / sizeof(uint32_t), buffer_size_);
   }
   virtual size_t GetTotalSize(void) {
     return file_offset_.back();
   }
   // implement next record
   virtual bool NextRecord(Blob *out_rec) {
     while (!ExtractNextRecord(out_rec, &tmp_chunk_)) {
       if (!NextChunkEx(&tmp_chunk_)) return false;
     }
     return true;
   }
   // implement next chunk
   virtual bool NextChunk(Blob *out_chunk) {
     while (!ExtractNextChunk(out_chunk, &tmp_chunk_)) {
       if (!NextChunkEx(&tmp_chunk_)) return false;
     }
     return true;
   }
   // implement ResetPartition.
   virtual void ResetPartition(unsigned rank, unsigned nsplit);
   virtual bool ReadChunk(void *buf, size_t *size);
   bool ExtractNextChunk(Blob *out_rchunk, Chunk *chunk);
   virtual bool ExtractNextRecord(Blob *out_rec, Chunk *chunk) = 0;
   virtual bool IsTextParser(void) = 0;
   virtual bool NextChunkEx(Chunk *chunk) {
     if (!chunk->Load(this, buffer_size_)) return false;
     return true;
   }
   virtual bool NextBatchEx(Chunk *chunk, size_t n_records) {
     return NextChunkEx(chunk);
   }
 
  protected:
   /*! \brief FileSystem */
   FileSystem *filesys_;
   /*! \brief byte-offset of each file */
   std::vector<size_t> file_offset_;
   /*! \brief get the current offset */
   size_t offset_curr_;
   /*! \brief beginning of offset */
   size_t offset_begin_;
   /*! \brief end of the offset */
   size_t offset_end_;
   /*! \brief information about files */
   std::vector<FileInfo> files_;
   /*! \brief current input stream */
   SeekStream *fs_;
   /*! \brief file pointer of which file to read on */
   size_t file_ptr_;
   /*! \brief file pointer where the end of file lies */
   size_t file_ptr_end_;
   /*! \brief temporal chunk */
   Chunk tmp_chunk_;
   /*! \brief buffer size */
   size_t buffer_size_;
   // constructor
   InputSplitBase()
       : fs_(NULL),
         tmp_chunk_(kBufferSize),
         buffer_size_(kBufferSize),
         align_bytes_(8) {}
   void Init(FileSystem *fs,
             const char *uri,
             size_t align_bytes,
             const bool recurse_directories = false);
   // to be implemented by child class
   /*!
    * \brief seek to the beginning of the first record
    *        in current file pointer
    * \return how many bytes we read past
    */
   virtual size_t SeekRecordBegin(Stream *fi) = 0;
   /*!
    * \brief find the last occurance of record header
    * \param begin beginning of the buffer
    * \param end end of the buffer
    * \return the pointer between [begin, end] indicating the
    *         last record head
    */
   virtual const char*
   FindLastRecordBegin(const char *begin, const char *end) = 0;
 
   /*! \brief split string list of files into vector of URIs */
   std::vector<URI> ConvertToURIs(const std::string& uri);
   /*! \brief same as stream.Read */
   size_t Read(void *ptr, size_t size);
 
  private:
   /*! \brief bytes to be aligned */
   size_t align_bytes_;
   /*! \brief internal overflow buffer */
   std::string overflow_;
   /*! \brief initialize information in files */
   void InitInputFileInfo(const std::string& uri,
                          const bool recurse_directories);
   /*! \brief strip continous chars in the end of str */
   std::string StripEnd(std::string str, char ch);
 };
```
