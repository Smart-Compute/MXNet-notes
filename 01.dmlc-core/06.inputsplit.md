## InputSplit
```
 class InputSplit {
  public: 
   struct Blob {  // 定义内存块
     void *dptr;  // 起始位置
     size_t size; // 内存块大小
   };
   virtual ~InputSplit(void) DMLC_THROW_EXCEPTION {}
   virtual void HintChunkSize(size_t chunk_size) {}
   virtual size_t GetTotalSize(void) = 0;
   virtual void BeforeFirst(void) = 0;
   virtual bool NextRecord(Blob *out_rec) = 0;  // text: 返回下一行; recordio: 返回下一个record
   /*
    * get a chunk of memory that can contain multiple records
    * This function ensures there won't be partial record in the chunk
    */
   virtual bool NextChunk(Blob *out_chunk) = 0;
   virtual bool NextBatch(Blob *out_chunk, size_t n_records) {
     return NextChunk(out_chunk);
   }
   virtual void ResetPartition(unsigned part_index, unsigned num_parts) = 0; // 重置为新的分片
   
   static InputSplit* Create(const char *uri, unsigned part_index, unsigned num_parts, const char *type);
   static InputSplit* Create(const char *uri, const char *index_uri, unsigned part_index, unsigned num_parts,
                             const char *type, const bool shuffle = false, const int seed = 0,
                             const size_t batch_size = 256, const bool recurse_directories = false);
 };
```
## InputSplitBase
```
 class InputSplitBase : public InputSplit {
  public:                  
   struct Chunk { // Blob的底层存储容器
     char *begin; char *end;
     std::vector<uint32_t> data;
     explicit Chunk(size_t buffer_size) : begin(NULL), end(NULL), data(buffer_size + 1) {}
     
     bool Load(InputSplitBase *split, size_t buffer_size);   // 从inputsplit读取数据，填充到data
     bool Append(InputSplitBase *split, size_t buffer_size); // 从inputsplit读取数据，追加到data末尾
   };
   static const size_t kBufferSize = 2UL << 20UL; // 2MB
   
   virtual ~InputSplitBase(void);
   
   virtual void HintChunkSize(size_t chunk_size) {
     buffer_size_ = std::max(chunk_size / sizeof(uint32_t), buffer_size_);
   }
   virtual size_t GetTotalSize(void) { return file_offset_.back(); } // 返回整个input的字节数
   virtual void ResetPartition(unsigned rank, unsigned nsplit); // 重置输入分片

   virtual void BeforeFirst(void);
   virtual bool NextRecord(Blob *out_rec) {
     while (!ExtractNextRecord(out_rec, &tmp_chunk_)) { // 从当前chunk读取一个record
       if (!NextChunkEx(&tmp_chunk_)) return false;     // 读取下一个chunk
     }
     return true;
   }
   virtual bool NextChunk(Blob *out_chunk) {
     while (!ExtractNextChunk(out_chunk, &tmp_chunk_)) { // 读取当前chunk
       if (!NextChunkEx(&tmp_chunk_)) return false;      // 读取下一个chunk
     }
     return true;
   }

   bool ExtractNextChunk(Blob *out_rchunk, Chunk *chunk) { // 读取当前chunk
     if (chunk->begin == chunk->end) return false; // 当前chunk无数据，需要读入下一个chunk
     out_chunk->dptr = chunk->begin;
     out_chunk->size = chunk->end - chunk->begin;
     chunk->begin = chunk->end;
     return true;
   }
   virtual bool NextChunkEx(Chunk *chunk) { // 从inputsplit读取下一个chunk
     return chunk->Load(this, buffer_size_);
   }
   virtual bool NextBatchEx(Chunk *chunk, size_t n_records) {
     return NextChunkEx(chunk);
   }
   
   virtual bool ReadChunk(void *buf, size_t *size);
   virtual bool ExtractNextRecord(Blob *out_rec, Chunk *chunk) = 0; // 从chunk中读取下一个record
   virtual bool IsTextParser(void) = 0;
 
  protected:
   FileSystem *filesys_;

   std::vector<size_t> file_offset_;
   size_t offset_curr_;
   size_t offset_begin_;
   size_t offset_end_;

   std::vector<FileInfo> files_;

   SeekStream *fs_;
   size_t file_ptr_;
   size_t file_ptr_end_;

   Chunk tmp_chunk_;
   size_t buffer_size_;

   InputSplitBase()
       : fs_(NULL),
         tmp_chunk_(kBufferSize),
         buffer_size_(kBufferSize),
         align_bytes_(8) {}
   void Init(FileSystem *fs,
             const char *uri,
             size_t align_bytes,
             const bool recurse_directories = false);

   virtual size_t SeekRecordBegin(Stream *fi) = 0;
   virtual const char* FindLastRecordBegin(const char *begin, const char *end) = 0;

   std::vector<URI> ConvertToURIs(const std::string& uri);
   size_t Read(void *ptr, size_t size);
 
  private:
   size_t align_bytes_;
   std::string overflow_;

   void InitInputFileInfo(const std::string& uri, const bool recurse_directories);
   std::string StripEnd(std::string str, char ch);
 };
```
