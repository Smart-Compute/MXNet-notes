## type_traits
利用模板特化，实现了`IfThenElseType`, `is_pod`, `is_integral`, `is_floating_point`, `is_arithmetic`, `type_name`；
```
 template<bool cond, typename Then, typename Else>
 struct IfThenElseType;

 template<typename Then, typename Else>
 struct IfThenElseType<true, Then, Else> {
   typedef Then Type;
 };
 
 template<typename Then, typename Else>
 struct IfThenElseType<false, Then, Else> {
   typedef Else Type;
 };
```
## optional
```
 template<typename T>
 class optional {
  public:
   optional() : is_none(true) {}
   explicit optional(const T& value) {
     is_none = false;
     new (&val) T(value);
   }
   ... // 拷贝构造、赋值、相等函数
   T& operator*() { return *reinterpret_cast<T*>(&val); }
   const T& value() const { // 获取const引用值
     if (is_none) {
       throw std::logic_error("bad optional access");
     }
     return *reinterpret_cast<const T*>(&val);
   }
   explicit operator bool() const { return !is_none; } // 判断是否有值
   bool has_value() const { return operator bool(); }
  private:
   // whether this is none
   bool is_none;
   // on stack storage of value
   typename std::aligned_storage<sizeof(T), alignof(T)>::type val;
 };
```
## FieldEntry
```
 class FieldAccessEntry {
  public:
   FieldAccessEntry() : has_default_(false), index_(0) {}
   virtual ~FieldAccessEntry() {}  
   
   virtual void SetDefault(void *head) const = 0;
   virtual void Set(void *head, const std::string &value) const = 0;
   virtual void Check(void *head) const {}
   virtual std::string GetStringValue(void *head) const = 0;
   virtual ParamFieldInfo GetFieldInfo() const = 0;
        
  protected:
   bool has_default_; // 是否有默认值
   size_t index_;     // 字段在struct中的序号
   std::string key_;  // 字段名字
   std::string type_; // 字段类型
   std::string description_; // 字段描述
   
   virtual void PrintDefaultValueString(std::ostream &os) const = 0;
   friend class ParamManager;  
 };
 
 template<typename TEntry, typename DType>
 class FieldEntryBase : public FieldAccessEntry {
  protected:
   ptrdiff_t offset_;    // 字段在struct中的字节偏移位置
   DType default_value_; // 字段默认值

  protected:
   inline DType &Get(void *head) const {
    return *(DType*)((char*)(head) + offset_); // 通过偏移位置获取字段
   }

  public:
   typedef TEntry EntryType; // 子类类型
   inline TEntry &self() { return *(static_cast<TEntry*>(this)); } /* 获取子类的引用 */

   /* 反序列化，通过istream读入值：std::istringstream is(value); is >> this->Get(); */
   virtual void Set(void *head, const std::string &value) const;
   /* 序列化，通过ostream输出值：std::ostringstream os; os << this->Get(); */
   virtual std::string GetStringValue(void *head) const;
   /* 获取name、type、type_info_str及description； */
   virtual ParamFieldInfo GetFieldInfo() const;
   virtual void SetDefault(void *head) const; // 当有默认值时，设置默认值，否则，报错；

   /* 设置字段名称、类型、字节偏移位置 */
   inline void Init(const std::string &key, void *head, DType &ref) {
    this->key_ = key; // 字段名字
    if (this->type_.length() == 0) {
     this->type_ = dmlc::type_name<DType>(); // 字段类型
    }
    this->offset_ = ((char*)&ref) - ((char*)head); // 字段字节偏移位置
   }
   inline TEntry &set_default(const DType &default_value);  // 设置字段默认值
   inline TEntry &describe(const std::string &description); // 设置字段描述
 };

 template<typename TEntry, typename DType>
 class FieldEntryNumeric : public FieldEntryBase<TEntry, DType> {
  protected:
   bool has_begin_, has_end_; /* 上下限标记 */
   DType begin, end_;         /* 上下限值 */

  public:
   FieldEntryNumeric(): has_begin_(false), has_end_(false) {}

   virtual TEntry &set_range(DType begin, DType end) { /* 设置数值范围 */
     begin_ = begin; end_ = end;
     has_begin_ = true; has_end_ = true;
     return this->self();
   }
   virtual TEntry &set_lower_bound(DType begin); /* 设置下限值 */
   virtual TEntry &set_upper_bound(DType end);   /* 设置上限值 */
   virtual void Check(void *head) const;         /* 检查字段是否越限 */
 };

 template<typename DType>
 class FieldEntry :
       public IfThenElseType<dmlc::is_arithmetic<DType>::value,
                             FieldEntryNumeric<FieldEntry<DType>, DType>,
                             FieldEntryBase<FieldEntry<DType>, DType> >::Type {
 };

 /* int特化，支持枚举类型 */
 template<>
 class FieldEntry<int> : public FieldEntryNumeric<FieldEntry<int>, int> {
  protected:
   bool is_enum_;                             // 枚举类型标记
   std::map<std::string, int> enum_map_;      // 枚举字面 => int
   std::map<int, std::string> enum_back_map_; // int => 枚举字面

  public:
   FieldEntry<int>() : is_enum_(false) {}

   typedef FieldEntryNumeric<FieldEntry<int>, int> Parent;
   virtual void Set(void *head, const std::string &value) const {
     if (is_enum_) { // 支持枚举类型按字面值设置
       std::map<std::string, int>::const_iterator it = enum_map_.find(value);
       std::ostringstream os;
       if (it == enum_map_.end()) {
         os << "Invalid Input: \'" << value;
         os << "\', valid values are: ";
         PrintEnums(os);
         throw dmlc::ParamError(os.str());
       } else {
         os << it->second;
         Parent::Set(head, os.str());
       }
     } else {
       Parent::Set(head, value);
     }
   }
   virtual ParamFieldInfo GetFieldInfo() const; // 针对枚举类型生成type_info_str
   inline FieldEntry<int> &add_enum(const std::string &key, int value); // 添加枚举值
 };

```
## ParamManager
## Parameter
