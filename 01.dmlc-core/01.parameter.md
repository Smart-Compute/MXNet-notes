## type_traits
利用模板特化，实现了`IfThenElseType`, `is_pod`, `is_integral`, `is_floating_point`, `is_arithmetic`, `type_name`；
```
 template<bool cond, typename Then, typename Else>
 struct IfThenElseType;

 template<typename Then, typename Else>
 struct IfThenElseType<true, Then, Else> {
   typedef Then Type;
 };
 
 template<typename Then, typename Else>
 struct IfThenElseType<false, Then, Else> {
   typedef Else Type;
 };
```
## FieldEntry
```
 class FieldAccessEntry {
  public:
   FieldAccessEntry() : has_default_(false), index_(0) {}
   virtual ~FieldAccessEntry() {}  
   
   virtual void SetDefault(void *head) const = 0;
   virtual void Set(void *head, const std::string &value) const = 0;
   virtual void Check(void *head) const {}
   virtual std::string GetStringValue(void *head) const = 0;
   virtual ParamFieldInfo GetFieldInfo() const = 0;
        
  protected:
   bool has_default_; // 是否有默认值
   size_t index_;     // 字段在struct中的序号
   std::string key_;  // 字段名字
   std::string type_; // 字段类型
   std::string description_; // 字段描述
   
   virtual void PrintDefaultValueString(std::ostream &os) const = 0;
   friend class ParamManager;  
 };
 
 template<typename TEntry, typename DType>
 class FieldEntryBase : public FieldAccessEntry {
  protected:
   ptrdiff_t offset_;    // 字段在struct中的字节偏移位置
   DType default_value_; // 字段默认值

  protected:
   inline DType &Get(void *head) const {
    return *(DType*)((char*)(head) + offset_); // 通过偏移位置获取字段
   }

  public:
   typedef TEntry EntryType; // 子类类型
   inline TEntry &self() { return *(static_cast<TEntry*>(this)); } /* 获取子类的引用 */

   /* 反序列化，通过istream读入值：std::istringstream is(value); is >> this->Get(); */
   virtual void Set(void *head, const std::string &value) const;
   /* 序列化，通过ostream输出值：std::ostringstream os; os << this->Get(); */
   virtual std::string GetStringValue(void *head) const;
   /* 获取name、type、type_info_str及description； */
   virtual ParamFieldInfo GetFieldInfo() const;
   virtual void SetDefault(void *head) const; // 当有默认值时，设置默认值，否则，报错；

   /* 设置字段名称、类型、字节偏移位置 */
   inline void Init(const std::string &key, void *head, DType &ref) {
    this->key_ = key; // 字段名字
    if (this->type_.length() == 0) {
     this->type_ = dmlc::type_name<DType>(); // 字段类型
    }
    this->offset_ = ((char*)&ref) - ((char*)head); // 字段字节偏移位置
   }
   inline TEntry &set_default(const DType &default_value);  // 设置字段默认值
   inline TEntry &describe(const std::string &description); // 设置字段描述
 };

 template<typename TEntry, typename DType>
 class FieldEntryNumeric : public FieldEntryBase<TEntry, DType> {
  protected:
   bool has_begin_, has_end_; /* 上下限标记 */
   DType begin, end_;         /* 上下限值 */

  public:
   FieldEntryNumeric(): has_begin_(false), has_end_(false) {}

   virtual TEntry &set_range(DType begin, DType end) { /* 设置数值范围 */
     begin_ = begin; end_ = end;
     has_begin_ = true; has_end_ = true;
     return this->self();
   }
   virtual TEntry &set_lower_bound(DType begin); /* 设置下限值 */
   virtual TEntry &set_upper_bound(DType end);   /* 设置上限值 */
   virtual void Check(void *head) const;         /* 检查字段是否越限 */
 };

 template<typename DType>
 class FieldEntry :
       public IfThenElseType<dmlc::is_arithmetic<DType>::value,
                             FieldEntryNumeric<FieldEntry<DType>, DType>,
                             FieldEntryBase<FieldEntry<DType>, DType> >::Type {
 };

 
```
## ParamManager
## Parameter
