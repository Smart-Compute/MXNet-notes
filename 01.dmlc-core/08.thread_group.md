## ManualEvent
简单的信号封装，支持设置/清空信号，支持等待信号；
```c++
 class ManualEvent {
  public:
   ManualEvent() : signaled_(false) {}

   void wait() { // 等待信号触发
     std::unique_lock<std::mutex> lock(mutex_);
     if (!signaled_) { condition_variable_.wait(lock); }
   }

   void signal() { // 触发信号
     signaled_ = true;
     std::unique_lock<std::mutex> lk(mutex_);
     condition_variable_.notify_all();
   }

   void reset() { // 重置信号
     std::unique_lock<std::mutex> lk(mutex_);
     signaled_ = false;
   }

  private:
   std::mutex mutex_;
   std::condition_variable condition_variable_;
   std::atomic<bool> signaled_;
 };
```
## Thread
```c++
 class Thread {
  private:
     std::string name_;  // 线程名
     std::atomic<std::thread *> thread_; // 线程对象
     ThreadGroup *owner_;  // 当前线程所属线程组
     mutable SharedMutex thread_mutex_;
     std::shared_ptr<ManualEvent> ready_event_;
     std::shared_ptr<ManualEvent> start_event_;
     std::atomic<bool> shutdown_requested_;
     volatile bool auto_remove_;
  public:
   using SharedPtr = std::shared_ptr<Thread>;
 
   Thread(std::string threadName, ThreadGroup *owner, std::thread *thrd = nullptr)
     : name_(std::move(threadName)), thread_(thrd)
       , ready_event_(std::make_shared<ManualEvent>())
       , start_event_(std::make_shared<ManualEvent>())
       , owner_(owner), shutdown_requested_(false), auto_remove_(false) {
     CHECK_NOTNULL(owner);
   }

   virtual ~Thread() {
     const bool self_delete = is_current_thread();
     if (!self_delete) {
       request_shutdown();
       internal_join(true);
     }
     WriteLock guard(thread_mutex_);
     if (thread_.load()) {
       std::thread *thrd = thread_.load();
       thread_ = nullptr;
       if (self_delete) {
       request_shutdown();
       internal_join(true);
     }
     WriteLock guard(thread_mutex_);
     if (thread_.load()) {
       std::thread *thrd = thread_.load();
       thread_ = nullptr;
       if (self_delete) {
         thrd->detach();
       }
       delete thrd;
     }
   }

   template<typename StartFunction, typename ...Args>
   static bool launch(std::shared_ptr<Thread> pThis,
                      bool autoRemove, StartFunction start_function, Args ...args);

   const char *name() const { return name_.c_str(); }
   std::thread::id get_id() const {
     ReadLock guard(thread_mutex_);
     return thread_.load()->get_id();
   }
   bool is_current_thread() const {
     ReadLock guard(thread_mutex_);
     return thread_.load() ? (thread_.load()->get_id() == std::this_thread::get_id()) : false;
   }

   virtual void request_shutdown() { shutdown_requested_ = true; }
   virtual bool is_shutdown_requested() const { return shutdown_requested_.load(); }

   bool is_auto_remove() const { return auto_remove_; }
   void make_joinable() { auto_remove_ = false; }

   bool joinable() const {
     ReadLock guard(thread_mutex_);
     if (thread_.load()) {
       CHECK_EQ(auto_remove_, false);
       return thread_.load()->joinable();
     }
     return false;
   }
   void join() { internal_join(false); }

  private:
   void internal_join(bool auto_remove_ok) {
     ReadLock guard(thread_mutex_);
     if (thread_.load() && thread_.load()->get_id() != std::thread::id()) {
       std::thread::id someId;
       if (!auto_remove_ok) { CHECK_EQ(auto_remove_, false); }
       if (thread_.load()->joinable()) {
         thread_.load()->join();
       } else {
         LOG(WARNING) << "Thread " << name_ << " ( "
                      << thread_.load()->get_id() << " ) not joinable";
       }
     }
   }

   template <typename StartFunction, typename ...Args>
   static int entry_and_exit_f(std::shared_ptr<Thread> pThis, /* std::thread封装执行的函数 */
                               StartFunction start_function, Args... args);
 };

 template <typename StartFunction, typename ...Args>
 inline int Thread::entry_and_exit_f(std::shared_ptr<Thread> pThis,
                                     StartFunction start_function, Args... args) {
   int rc;
   if (pThis) {
     pThis->ready_event_->signal(); // 通知launcher线程已经开始运行
     pThis->start_event_->wait();   // 等待launcher通知继续执行
     pThis->start_event_->reset();  // 重置信号以便可重复执行
     if (!pThis->is_shutdown_requested()) { // 可执行
       rc = start_function(args...); // 运行具体的函数
     } else { // 要求退出
       rc = -1;
     }
     if (pThis->is_auto_remove()) { // 线程退出时，自动从ThreadGroup注销
       pThis->owner_->remove_thread(pThis);
     }
     pThis.reset(); // 释放引用
   } else { // 异常case
     LOG(ERROR) << "Null pThis thread pointer";
     rc = EINVAL;
   }
   return rc;
 }

 template<typename StartFunction, typename ...Args>
 inline bool Thread::launch(std::shared_ptr<Thread> pThis, bool autoRemove,
                            StartFunction start_function, Args ...args) {
   WriteLock guard(pThis->thread_mutex_);
   CHECK_EQ(!pThis->thread_.load(), true); // Thread刚创建且没有创建std::thread对象
   CHECK_NOTNULL(pThis->owner_);
   pThis->auto_remove_ = autoRemove;
   pThis->thread_ = new std::thread(Thread::template entry_and_exit_f<StartFunction, Args...>,
                                    pThis, tart_function, args...);
   if (!pThis->owner_->add_thread(pThis)) { // 添加到线程组，线程名冲突添加失败
     pThis->request_shutdown(); // 给线程发送退出信号
     LOG(ERROR) << "Duplicate thread name within the same thread group is not allowed";
   }
   pThis->ready_event_->wait(); // 等待线程开始运行
   pThis->start_event_->signal(); // 给线程发送继续执行信号
   return pThis->thread_.load() != nullptr;
 }
```
## ThreadGroup
